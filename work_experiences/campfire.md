---
layout: page
title: 株式会社CAMPFIRE (2019/2 ~ 現在)
---

## プロジェクトA: モバイルアプリのサーバーサイド開発

#### プロジェクト概要

- 業務内容
  - モバイルアプリ用のサーバーサイド（RailsアプリケーションにREST APIを追加 + GrapQLのBFFを新規作成)
- 主な使用技術
  - Rails, TypeScript, GraphQL, Apollo Server
- チーム構成
  - PO1人、デザイナー1人、iOSエンジニア1人、Androidエンジニア1人、サーバーサイドエンジニア1人(自分)

#### こだわった点１：Railsアプリケーションの肥大化を最小限に抑える

既存のRailsアプリケーションは、既に肥大化しており、歴史的経緯により複数のウェブサービスが一つのRailsアプリケーション内で動いているものです。
複数種類のユーザーに対応するビューがあり、また、複数種類のクライアントを想定したAPIがいくつもある、という状態です。

モバイルアプリの開発が始まると決まった当初は、そのRailsアプリケーション内にモバイルアプリが叩くAPIを生やす想定でした。
そうなると、Railsアプリケーションが想定するクライアントの種類は更に増え、肥大化に拍車がかかります。

**肥大化防止案A: 別アプリケーションでモバイル用のAPIを実装する**

最初は別アプリケーションで実装することを検討しましたが、共通のビジネスロジックが大量にあるため、こちらは現実的には難しいことが判明して断念しました。

**肥大化防止案B: 特定のクライアントに依存しない新しいAPIを既存Railsアプリケーションに実装する**

案Aの次には、「あらゆるクライアントが使いまわせる汎用的なREST API」＋「モバイル専用のBFF」という構成に方針を転換することを提案しました。

- 1つのエンドポイントでは、DBの1つテーブルのデータのみ返す（BFFでクライアントに実際に必要なデータを集める）ので、Rails側の実装は非常にシンプルで済む
- 将来的には、既存のAPIは新しく作成するREST APIに統合される想定なので、肥大化の阻止につながる

この案のデメリットとしては、層が一つ増えることで、実装の工数が大幅に増えるのではないかという懸念がありました。GraphQLについての知見がある人が社内にいないことも重なり、PMはこの案に対して懐疑的でした。
この懸念は、簡単なGraphQLアプリケーションを作成してみることによって、BFFの実装にかかる時間を見積もることによって解消することができました。

#### こだわった点２：データの取得元の変更に強い設計

今回作成したBFFは、2つのバックエンドを参照します。

A. 既存のRailsアプリケーション
B. 検索の外部SaaSが提供しているAPI

同じデータであっても、取得時の順序や絞り込みによって、参照するバックエンドは異なります。
将来的に、参照するバックエンドがA→B、あるいはB→Aのように変更する可能性は非常に高いです。

そこで、今回はClean Architectureなアプローチを採用し、BFFのコードにデータの取得のみのための層を作成しました。
この層は更に上位の層で定義されたインタフェースを実装するもので、参照するバックエンドが変更されたとしても、データ取得層以外には影響しません。


## プロジェクトB: ユーザーインタビューツールのサーバーサイド+フロントエンド開発

#### プロジェクト概要

- 業務内容
  - ユーザーインタビューツールの新規開発
- 主な使用技術
  - Rails, Vue, nuxt, TypeScript, Terraform, AWS, netlify, storybook
- チーム構成
  - PO1人、デザイナー1人、iOSエンジニア1人、Androidエンジニア1人、サーバーサイド＋ウェブフロントエンド1人(自分)

自分はウェブのフロントエンド（企業向け画面、運営用の管理画面、一般ユーザー向けアプリ誘導ページ）、サーバーサイド全般、インフラの一部を担当しました。
完全にゼロからの開発だったので、技術選定、DB設計、API設計、CIの構築などを全てこなしました。

#### ウェブの企業向け画面、運営用の管理画面
こちらはnuxt.js+Vue.jsで実装しました。実装をはじめた当初は、フロントエンド開発はjQueryやVanilla JSの経験しかありませんでした。
社内にもVueやReactなどのフロントエンドフレームワークの経験が豊富なエンジニアはいませんでした。

使用技術の選定理由は以下の通りです。
- Vue.js
  - React.jsに比べて学習ハードルが低い
  - CSSが適用されるスコープを限定することができる
- nuxt.js
  - フロントエンドの経験が浅い人でも開発しやすいようにVue.jsを使う際のベストプラクティスを用意してくれる
- Typescript
  - APIからのレスポンスや、storeに保存するデータを型で定義することによって、利用しやすくする
  - 実行時エラーを減らす
- storybook
  - デザイナーとコンポーネントのデザインと挙動の認識を合わせるために有効
  - 後から参加するエンジニアがコンポーネントシステムの全体像を掴みやすい
  - コンポーネント単体の開発が非常にしやすい
  - スナップショットテストができる

SSRを使う必要がなく、githubと連携してデプロイが可能だったため、netlifyを使って公開しました。

#### 一般ユーザー向けアプリ誘導ページ

こちらは、ページ数5枚程度で、動的な部分も一部のみのシンプルなものでした。
仕様が非常にシンプルだったので、なるべく工数をかけずに素早くリリースするために生のHTML + Javascriptで作成しました。
S3の静的ホスティングを利用して公開しました。

#### サーバーサイド

こちらはRuby on Rails（APIモード）で実装しました。
大きく分けて、内容以下の３つです。
- iOS / Androidが使うモバイル用のAPI
- 企業向け画面が使うウェブ用のAPI
- 運営用の管理画面が使うウェブ用のAPI

開発する上で注意した点は、テストを充実させることです。

初期の開発は仕様の変更が激しく、1人で開発しているので属人性が高くなりやすいです。
また、過去に携わったプロジェクトでは、テストコードがないせいでリファクタリングがしにくく、コードの質が悪化し続けて新規の開発が遅くなる現場を多く見てきたので、個人的にそういう事態を避けたいという強
い思いもありました。

単体テストだけではなく、結合テストも充実させたおかげで、以下の作業を素早く、安心して行うことができました。
- 既存機能の改修、リファクタリング
- 新機能追加
- リファクタリング
- Railsのバージョンアップ（5 -> 6）

AWS Fargateを使って公開し、Terraformを使って構成管理しました。（Fargate関連の構築は他の方にサポートしていただきました）


## プロジェクトC: 金融系サービスのサーバーサイド+フロントエンド開発

#### プロジェクト概要

- 業務内容
  - 既存のRailsアプリケーションの運用・新機能追加
- 主な使用技術
  - Rails, React
- チーム構成
  - PO1人、デザイナー1人、エンジニア5人

#### プロジェクト詳細

歴史的な経緯により、いろんな開発者が開発に携わったプロジェクトなので、リファクタリングをしながら新規開発を進めた。
既存の挙動を保ちつつ、モデルやコントローラーを分割した。
POがエンジニア出身であったため、リファクタリングに理解があり、やりやすかった。

また、コードの書き方が統一されず、新しく参加する開発者がどの書き方を参考にすれば良いのか迷うという課題があるので、コーディング規約の策定も進めている。